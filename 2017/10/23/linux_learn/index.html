<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>鸟哥的linux私房菜读书笔记 | 会一点PHP和Go的Junior Developer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="0、计算机概论一、硬件五大单元  输入单元、输出单元、CPU控制单元、CPU算数逻辑单元、内存二、CPU种类：精简指令集：复杂命令要多个指令完成复杂指令集：每个小指令都可以执行低阶硬件操作， 指令多而且发展。 AMD Intel VIA x86 使用三、计算单位文件大小用二进制 bit  1Byte＝8bit 速度使用十进制 Hz（秒分之一）硬盘制造商使用十进制单位四、 接口设备北桥负责链接CPU">
<meta name="keywords" content="linux">
<meta property="og:type" content="article">
<meta property="og:title" content="鸟哥的linux私房菜读书笔记">
<meta property="og:url" content="http://yoursite.com/2017/10/23/linux_learn/index.html">
<meta property="og:site_name" content="会一点PHP和Go的Junior Developer">
<meta property="og:description" content="0、计算机概论一、硬件五大单元  输入单元、输出单元、CPU控制单元、CPU算数逻辑单元、内存二、CPU种类：精简指令集：复杂命令要多个指令完成复杂指令集：每个小指令都可以执行低阶硬件操作， 指令多而且发展。 AMD Intel VIA x86 使用三、计算单位文件大小用二进制 bit  1Byte＝8bit 速度使用十进制 Hz（秒分之一）硬盘制造商使用十进制单位四、 接口设备北桥负责链接CPU">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2018-10-23T08:25:56.746Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="鸟哥的linux私房菜读书笔记">
<meta name="twitter:description" content="0、计算机概论一、硬件五大单元  输入单元、输出单元、CPU控制单元、CPU算数逻辑单元、内存二、CPU种类：精简指令集：复杂命令要多个指令完成复杂指令集：每个小指令都可以执行低阶硬件操作， 指令多而且发展。 AMD Intel VIA x86 使用三、计算单位文件大小用二进制 bit  1Byte＝8bit 速度使用十进制 Hz（秒分之一）硬盘制造商使用十进制单位四、 接口设备北桥负责链接CPU">
  
    <link rel="alternate" href="/atom.xml" title="会一点PHP和Go的Junior Developer" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">会一点PHP和Go的Junior Developer</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">天行健 君子以自强不息 地势坤 君子以厚德载物</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-linux_learn" class="article article-type-post" itemscope="" itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/10/23/linux_learn/" class="article-date">
  <time datetime="2017-10-23T07:27:48.000Z" itemprop="datePublished">2017-10-23</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      鸟哥的linux私房菜读书笔记
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>0、计算机概论<br>一、硬件五大单元  输入单元、输出单元、CPU控制单元、CPU算数逻辑单元、内存<br>二、CPU种类：<br>精简指令集：复杂命令要多个指令完成<br>复杂指令集：每个小指令都可以执行低阶硬件操作， 指令多而且发展。 AMD Intel VIA x86 使用<br>三、计算单位<br>文件大小用二进制 bit  1Byte＝8bit<br> 速度使用十进制 Hz（秒分之一）<br>硬盘制造商使用十进制单位<br>四、 接口设备<br>北桥负责链接CPU、内存、显卡等较快接口<br>南桥负责硬盘、USB、网卡等较慢接口<br>AMD讲内存控制组件集成到CPU， 不通过北桥。<br>五、CPU<br>多核是在一个CPU封装潜入两个以上运算内核<br>频率就是CPU每秒钟的工作次数  如3.0GHz，  就是每秒进行3<em>10^9 次工作<br>外频与倍频：外频指的是CPU与外部组建进行数据传输/计算时的速度， 倍频是CPU内部用来加速工作性能的倍数， 两者相乘是CPU的频率。<br>32位与64位： 北桥的总线成为系统总线 内存传输主要信道。 南桥是I/O总线 。 北桥支持频率是前端总线速度， 每次传送的位数就是总线宽度。总频宽度＝总线宽度</em>前端总线速度。<br>CPU每次能处理的数据量成为字组大小，  32位活64位 一句CPU解析的字组大小定义。 32位CPU最多支持4GB内存。<br>六、内存<br>只读存储器ROM：CMOS芯片需要接着额外的电源记录主板上的参数：系统时间、CPU电压频率、各设备I/O地址。 BIOS是一套程序， 写死在主板上一个芯片内，可以修改CMOS， 开机执行， 调用CMOS数据， 调用存储设备的开机程序。<br>七、显卡<br>显卡自带内存容量。越大越好。<br>八、硬盘与存储设备<br>传输接口：IDE SATA（现在主流） SCSI<br>选购注意：容量，缓冲存储器， 转速，<br>九、电源<br>输出的功率与输入的功率的比值就是转换率。 要挑选高转换率的电源。<br>十、数字系统<br>二进制转换为十进制：1101010 = 1<em>2^6 + 1</em>2^5 + 0<em>2^4 + 1</em>2^3 + 0<em>2^2 + 1</em>2^1 + 0*2^0 = 106<br>八进制、十六进制类似<br>十一、文字编码系统<br>编码系统想成一个“字码对照表”， 英文编码表ASCII系统， 中文常用big5(gb2312)， 仅定义了一万三千多个汉子， 所以 又执行了Unicode编码系统， 即UTF8<br>十二、操作系统<br>操作系统是一组程序， 重点在于管理计算机的所有活动以及驱动系统中的所有硬件。<br>内核程序在内存中的区块是受保护的， 开机后一直存在内存中。<br>计算机系统由硬件构成，内核在于管理硬件，提供合理的计算机系统资源分配。操作系统除了内核外，还会提供一整组开发接口，就是系统调用层。<br>操作系统内核层直接参考硬件规格<br>操作系统只是在管理整个硬件资源，包括CPU、内存、输入输出设备及系统文件。<br>内核功能：系统调用接口、程序管理、内存管理、文件系统管理、设备驱动</p>
<p>1、Linux是什么<br>Linux 可以称为Unix Like操作系统的一种<br>Linux特色：自由与开放的使用与学习环境、配备需求低廉、内核功能强大而稳定、独立作业</p>
<p>3、主机规划与磁盘分区<br>一、Linux系统中， 每个设备都被当成一个文件来对待。几乎所有的硬件设备都在/dev目录下<br>二、磁盘：第一个扇区记录了两个重要信息 1主引导分区（可以安装引导加载程序的地方 446bytes）2分区表（记录整块硬盘分区的状态 46bytes）<br>三、开机流程与主引导分区<br>开机流程到系统之前的动作<br>a：BIOS 认识第一个可开机的设备<br>b：MBR（第一个扇区） 第一个可开机设备的第一个扇区内的主引导分区块，包含引导加载程序。<br>c：引导加载程序 读取内核文件来执行的程序。提供菜单-用户可以选择不同的开机程序，多重引到。 载入内核文件。转向其他引导加载程序。<br>d：内核文件 开始操作系统<br>注：每个分区都有自己的启动扇区。 世纪可开机的内核文件放置到各分区内。loader只会认识自己的系统分区的可开机内核文件及其他loader。 loader可直接指向或者间接将管理权交给另一个管理程序。<br>四、磁盘分区的选择<br>linux使用目录树结构<br>挂载：利用一个目录作为进入点，将磁盘分区的数据放置在该目录下。进入该目录就可以读取该分区。<br>磁盘的主分区和扩展分区最多有四个。逻辑分区的设备文件名号码一定从5开始<br>swap分区：存放内存溢出来的数据。<br>Swap分区在系统的物理内存不够用的时候，把硬盘空间中的一部分空间释放出来，以供当前运行的程序使用。那些被释放的空间可能来自一些很长时间没有什么操作的程序，这些被释放的空间被临时保存到Swap分区中，等到那些程序要运行时，再从Swap分区中恢复保存的数据到内存中。<br>如果系统的物理内存用光了，系统就会跑得很慢，但仍能运行；如果Swap空间用光了，那么系统就会发生错误。例如，Web服务器能根据不同的请求数量衍生出多个服务进程（或线程），如果Swap空间用完，则服务进程无法启动，通常会出现“application is out of memory”的错误，严重时会造成服务进程的死锁。</p>
<p>4、安装 与多重引导小技巧<br>一、文件类型<br>ext2/ext3：linux使用的文件系统类型。ext3多了日志的记录，对系统的恢复比较快速。<br>physical volume（LVM） 弹性调整文件系统大小的一种机制。让文件系统大小变大或变小而不改变原来的文件数据内容（待详细了解）<br>software RAID：利用linux操作系统的特性 用软件仿真出磁盘陈列的功能。（待详细了解）<br>swap：内存交换空间。swap不会使用目录树的挂载。最好为物理内存的1.5到2倍之间<br>vfat：同时被Linux与Windows支持的文件系统类型。如果同时存在Windows和Linux，为了数据交换，可以构建vfat的文件系统。<br>UTC 协调世界时 又称世界统一时间，世界标准时间，国际协调时间 中国大陆、中国的时间与UTC的时差均为+8，也就是UTC+8<br>GMT 格林尼治标准时间<br>SELinux：Linux系统访问控制的细化设置，重点在于控制程序对于系统文件的访问权限设置。<br>Kdump：内核出现错误的时候是否将内存内的消息写到文件。<br>二、两块以上硬盘只有一个MBR，因为BIOS里面调整开机启动设备，只有第一个可开机设备的MBR会被系统主动读取。</p>
<p>5、首次登陆与在线求助<br>一重启X Window快捷键 Alt + Ctrl + Backspace<br>ctrl+alt+[f1-f6] 终端 tty1-tty6  +f7  图形界面桌面<br>纯文本启动  命令 startx  有条件下打开图形界面桌面<br>～代表主文件夹<br>二 命令介绍<br>command [-options] param1 param2<br>加入参数设置带 - 如： -h 使用参数完整全名 用 — 如：—help  参数除了带- 某些情况也会带+  比如日期<br>中间空格区分， 空几格都理解为一格<br>用 反斜杠\ 转义回车符， 可以使命令持续到下一行<br>显示目前支持语言 echo $LANG 修改 LANG=en_US<br>三基础命令<br>显示日期与时间  date +%Y%m<br>显示日历 cal month year  如 cal 9 2009<br>简单计算器  bc  bc下默认输出整数 scale＝number 设置输出number位小数 quit离开<br>四 shell 热键<br>tab  命令补全   文件补全<br>CTRL+C  中断目前程序<br>CTRL+D 等于 exit+回车<br>五 在线求助 man page  和 info page<br>man （manual的简写)  查看命令的说明  如 man  date     命令下空格翻页， 输入q退出<br>man取得的数字代表含义<br>1-用户在shell环境中可以操作的命令或可执行文件<br>2-系统内核可调用的函数或工具等<br>3-一些常用的函数与函数库，大部分为C的函数库<br>4-设备文件的说明，通常在/dev下的文件<br>5-配置文件或者某些文件的格式<br>6-游戏<br>7-惯例与协议等（例如Linux文件系统，网络协议， ASCII code等说明）<br>8-系统管理员可用的管理命令<br>9-跟kernel有关的文件<br>man 模块<br>NAME：简短的命令、数据名称说明<br>SYNOPSIS：简短的命令执行语法简介<br>DESCRIPTION：较为完整的说明<br>OPTIONS：针对SYNOPSIS部分中有列举的所有可用的选项说明<br>COMMANDS：这个程序执行时可以在此程序中执行的命令<br>FILES：这个程序或数据使用或参考或链接的文件<br>SEE ALSO：命令或数据相关的其他说明<br>EXAMPLE：一些参考范例<br>BUGS：是否有相关错误<br>按键：空格\PageDown 向下翻一页 PageUp 向上翻一页 Home 第一页 End 最后一页 /string 向下查询string字符串 ?string 像上查询字符串 n 继续下一个查询  N 进行反向查询 q 退出<br>man page 修改查询路径 /etc/man.config  或manpath.config<br>man -f  命令 查找命令或文件的完整名称  man 1（命令或文件代表的意义） 命令 可以直接查找该意义命令   等于命令 whatis<br>man -k 关键字  只要有这个关键字就会找出来  等于命令 apropos<br>info page 将文件拆成一个一个段落，每个段落用自己的页面撰写，在各个页面有类似网页的超链接<br>按键： space\Page Down向下翻页 PageUp 向上翻页 tab 节点间移动 enter 进入该节点 b 光标移动到第一个节点 E 移动到最后一个节点 N 下一个节点 P 前一个节点 U 向上移动一层 S(/）查询 H 现实求助菜单<br>？命令一览表 Q退出<br>其他说明文档一般放在 /usr/share/doc<br>六、超简单文本编辑器 nano<br>七、正确的关机方法<br>sync：将内存中尚未被更新的数据写入硬盘。 shutdown/reboot/halt 关机前执行sync调用。<br>shutdown<br>-t sec ：加秒数， 即过几秒关机的意思<br>-k ： 不要真的关机， 只是发送警告消息出去<br>-r：将系统的服务停掉后重启<br>-h：将系统的服务停掉后立即关机<br>-n：不经过init程序，直接以shutdown的功能关机<br>-f：关机并开机之后，强制略过fsck的磁盘检查 (fsck：用来检查和维护不一致的文件系统。若系统掉电或磁盘发生问题，可利用fsck命令对文件系统进行检查。）<br>-F：系统重启后强制fsck磁盘检查<br>-c：取消已经在进行的shutdown命令<br>例：<br>shutdown -h now 立刻关机 shutdown -h +10 十分钟关机  shutdown -h 11:00  11点关机（24小时制）<br>切换执行等级 init  其中等级（之后详细了解） init 0 可以关机<br>root提示符是#  普通用户提示符是$</p>
<p>6 Linux的文件配置与目录配置<br>一、用户与用户组<br>每个账户都可以有多个用户组的支持<br>Linux一般将文件可存取访问的身份分为 owner group others 三个类别<br>系统账号与一般用户身份存放在/etc/passwd，个人密码存放在/etc/shwdow 组名记录在/etc/group<br>二、Linux文件属性<br>drwxr-xr-x   5 chadli  staff  170  7  1 10:34 .<br>drwxr-xr-x  14 chadli  staff  476  6 25 08:36 ..<br>-rw-r–r–   1 chadli  staff  410  7  8 10:01 index.php<br>文件权限 连接数 文件所有者 文件所属用户组 文件大小 修改日期 文件名<br>文件权限有10个字符<br>第一个字符：目录、文件或链接文件等 分别表示 d：目录 -：文件 l：链接文件 b：设备文件里面的可供存储的接口设备 c：设备文件里的串行端口设备如鼠标、键盘<br>之后三个为一组，均为rwx的组合。 r表示可读 对应数字4， w表示可写 对应数字2， x表示可执行 对应数字1<br>第2-4个字符：文件所有者(owner)的权限<br>第5-7个字符：同用户组(group)的权限<br>第8-10个字符：其他非本用户组(other)的权限<br>目录文件 有r 权限 没有x 权限， 也不能进此目录<br>连接数 - 每个文件都会将它的权限记录与属性记录到文件系统i-node中。记录有多少不同的文件名连接到相同的i-node<br>三、改变文件属性与权限<br>chgrp：改变文件所属用户组 命令： chgrp [-r(递归的持续修改，连同子目录下的所有文件目录)] 用户组 文件/文件夹<br>chown：改变文件所有者（也可以顺便直接修改用户组） 命令：chown [-r] 用户:组名 文件/目录<br>chmod：改变文件权限<br>有两种类型改变权限<br>数字类型：命令 chmod 664 index.php 各权限数字对应表   r 4   w 2  x 1<br>符号类型：u,g,o分别代表 user group other， a代表all，   符号 + - =   命令：chmod u=rwx,go=rx 文件   chmod a-x 文件<br>四、目录与文件的权限意义<br>Linux 文件是否能被执行是由是否具有x这个权限来决定。 r w x主要是针对文件内容。<br>权限对目录<br>r 读取目录结构列表的权限<br>w 新建新的文件与目录 删除已经存在的文件与目录（不论该文件权限如何，这个牛逼了） 将已存在的文件和目录重命名 转移目录内的文件、目录位置<br>x 代表用户能否进入改目录成为工作目录（工作目录就是目前所在的目录）<br>五、Linux文件种类与扩展名<br>任何设备在Linux下都是文件<br>文件种类包括<br>普通文件 属性 - 包括 纯文本文件（ASCII）（可以使用cat获取）；二进制文件（比如cat命令）；数据格式文件（使用last读取）<br>目录 属性 d<br>连接文件 （类似windows下的快捷方式）属性l<br>设备与设备文件  设备文件-存储数据 例如硬盘等。 属性b   字符设备文件-串行端口的接口设备 例如鼠标 键盘。属性c 套接字（sockets）-数据接口文件，通常被用在网络上的数据链接。属性s  管道（FIFO first-in-first-out）-解决多个程序同时访问一个程序造成的错误问题。属性p<br>六、Linux单一文件或目录最大容许文件名为255个字符。包含完整路径名及目录（/）的完整文件名为4096个字符。<br>七、Linux 目录配置标准 FHS<br>根目录/越小越好，且应用程序所安装的软件最好不要放在与根目录同一个分区。<br>/bin 放置在单用户维护模式下还能够操作的命令 如 cat chmod chown date bash等<br>/boot 放置开机会用到的文件 Linux kernel常用文件名为vmlinuz 如果使用grub， 还会存在/boot/grub/<br>/dev 任何设备与接口都是以文件的形式存放于这个目录<br>/etc 系统主要的配置文件就都放在这个目录。<br>/home 系统默认用户主文件夹<br>/lib 开机时用到的函数库  及在/bin或/sbin下面命令调用的函数库<br>/root 系统管理员root的主文件夹<br>/sbin 开机过程中需要的。<br>/lost+found 标准ext2/ext3 文件系统产生的目录，目的在于文件系统发生错误时，将一些丢失的片段放置到这个目录下，这个目录在分区醉顶层。<br>/proc 放置的数据都在内存当中<br>/etc /bin /dev /lib /sbin 不可与根目录分开放在不同分区<br>/usr（ UNIX Software Resource） 可分享不可变动的<br>/var 系统运行后逐渐占用硬盘的目录 /var/cache应用程序运行过程中产生的缓存 /var/lib 程序执行过程中需要用到的数据文件放置目录 /var/lock 某些设备或文件一次只能被一个应用程序使用 /var/log /var/spool 队列数据如crontab 放置在/var/spool/cron目录<br>.代表当前目录，可用./表示 ..表示上一层目录 可用../表示<br>命令：uname -r 查看实际的内核版本   </p>
<p>7 Linux文件与目录管理<br>一、目录相关操作<br>. 此层目录 .. 上层目录 - 上一个目录 ～ 目前用户所在文件夹  ～account  用户account的文件夹<br>处理目录的命令  cd(change directory)：切换目录 pwd(Print Working Directory)：显示当前目录：mkdir(make directory)：新建目录 rmdir：删除空目录<br>cd 不带路径同 cd ~<br>pwd -P 连接文件获取正确目录名称<br>mkdir -m 权限code 文件夹名  创建指定权限文件夹  比如 mkdir -m 711 test<br>二、执行文件路径的变量（环境变量）：PATH<br>打印环境变量路径  echo $PATH  添加环境变量目录 PATH=“$PATH”:目录名<br>三、ls cp mv rm<br>ls [-aAdfFhilnrRSt] -a：全部（包括隐藏文件）-A：全部文件（包括隐藏文件但不包括.  ..）-d：仅列出目录 -f：不进行排序（ls会根据文件名排序）-F：根据文件、目录附加数据结构如 <em>可执行文件 /目录 ＝socket文件 |FIFO文件 -h：将文件大小以GB KB列出来 -i：列出inode号码 -l：列出长数据串 -n：列出UID、GID -r：按排序结果反向输出 -R：连同子目录内容一起列出来 -S：以文件容量大小排序 -t：依时间排序<br>cp [-adfilprsu] 源文件 目录文件  cp的源文件与目的文件权限不同，目的文件所有者通常是命令操作本身<br>cp -a (等于-dpr) -d (文件为连接属性，复制连接而不是文件本身) -f (force强制) -i (目标文件存在时询问) -l (硬链接） -p(文件属性一起复制) -r(递归) -s(软链接) -u(目标文件比源文件旧才更新)<br>rm [-fir]<br>mv [-fiu] 源文件 目标文件<br>rename<br>basename 获取最后文件名<br>dirname 获取目录名<br>四、文件内容查阅命令<br>cat [-AbEnTv]：从第一行开始开始文字<br>tac：从最后一行开始显示（cat的倒写）<br>nl [-bnw]：显示的时候顺带行号<br>more：一页一页现实文件内容 辅助操作：空格(space)：向下翻一页 /：向下查找字符串 :f显示文件名和行数 q：退出 b：往回翻页<br>less：和more类似，但是可以往前翻页 辅助操作：space/pagedown 向下翻一页 pageup-向上翻一页 /：向下查找 ?：向上查找 n：重复前一个查询 N：反向重复前一个查询 q 离开这个程序<br>head [-n]：只看头几行（默认10行）  n为负数时表示限制除掉最后n行的内容<br>tail [-nf]：只看结尾几行  tail -n +100   100行以后列出来<br>od [-t] [-acdfox]：以二进制方式读取文件内容<br>五、修改文件时间或创建新文件 touch<br>文件有三个时间：modification times(mtime)内容更改时间 status time(ctime)状态(权限 属性)更改时间 access time(atime)读取时间  例：获取atime ls -l —time=atime index.php<br>touch [-acdmt]  -a：修改访问时间 -c：修改文件时间，不存在不新建 -d：接要修改的日期不用当前日期 也可以用“—date=“”” -m：仅修改mtime -t：后面跟要修改的时间，格式[YYmmDDhhmm]<br>六、文件默认权限与隐藏权限<br>umask 目前用户在新建文件或目录的权限默认值 umask的数字表示默认值需要减掉的权限， 比如rx 去掉了w 就是2  umask -S 返回符号说明<br>umask 022  修改默认权限<br>chattr 设置隐藏属性 操作符 [+-=] + - 只针对某个参数  ＝设置为后面的参数  参数[ASacdistu]<br>A：访问时不修改atime S：不经过内存直接存入磁盘 a：只能增加不能修改、删除 c：存储先压缩再存储，读取自动解压缩 d：dump时不会被备份 i：不能被删除、改名、设置连接、写入、添加数据 s：删除时从硬盘删除 u：删除时存在磁盘<br>lsattr [-adR] -a：隐藏文件的属性也秀出来 -d 仅列出目录不列出目录内文件 -R：连同子目录的数据也一并列出来<br>七、文件特殊权限<br>SUID(SetUID)：权限u 的x为s，<br>SGID(SetGID)：权限g的x为s<br>SBIT(Sticky Bit)：权限o的x为t<br>设置特殊权限  SUID＝4 GUID＝2 SBIT＝1  例 chmod 4755 test (test权限为-rwsr-xr-x) 或 chmod u=rwxs, go=x test;  或 chmod g+s, o+t test<br>八、查看文件类型 file  例：file test.php<br>九、脚本文件的查询  which  type<br>whitch [-a 列出所有PATH目录中的命令， 而不只是第一个]  which 根据用户设置的PATH变量查找。 例which  ls<br>十、文件名的查找<br>whereis [-bmsu]文件或目录名 -b：只找二进制格式文件 -m：只找说明文件manual路径下的文件 -s：只找source源文件 -u：查找不在上述三个选项当中的其他特殊文件<br>locate [-ir] keyword  -i：忽略大小写 ir：后面可接正则表达式的显示方式<br>Linux将系统的所有文件都记录在一个数据库文件里。whereis locate 都会以数据库文件内容为准。 系统会定时（如一天一次）更新数据库文件  用updatedb命令可以即使更新<br>updatedb：根据/etc/updatedb.conf 设置去查找系统硬盘内文件名  更新/var/lib/mlocate 数据文件 locate根据 /var/lib/mlocate 数据库记载， 找出用户输入的关键字文件名<br>find [PAHT] [PATH] [option] [action]<br>与时间有关：-atime -ctime -mtime  说明：  find /path -mtime [n 在n天之前的一天之内的被更改文件; +n：在n天之前（不含n天本身）的被更改文件 -n：n天之内（含n天）被更改的文件]     find /path -newer file ：file是一个文件，列出比file新的文件<br>与用户用户组相关：-uid：UID -gid：GID。-user：用户名 -group：用户组；-nouser：所有这不存在的文件 -nogroup：所有用户组不存在的文件<br>与用户权限有关：-name：文件名称  -size：+size 比size大的文件 -size 比size小的文件。 -type：类型为type的文件 有一般正规文件(f)、设备文件(b,c)、目录(d)、连接文件(l)、socket(s)、FIFO(p)。  -perm：mode文件权限等于mode的 -mode 权限要全部包含mode的 +mode 文件权限包含任一mode的<br>与其他可执行的操作： -exec command  其他命令来处理查询到的结果 -print：结果打印到屏幕上。 例 find / -perm +7000 -exec ls -l {} \; -exec 到\;是关键字，代表find额外命令的开始和结束 在这之间的就是find命令的额外命令<br>find支持通配符  如： find /etc -name ‘</em>httpd*’<br>十一、权限与命令的关系<br>ls需要r的权限；  命令 cp /dir1 file1 /dir2  需要dir1 x权限 file r权限 dir2 w r权限</p>
<p>8Linux磁盘与文件管理系统<br>一、格式化 因为每种操作系统所设置的文件属性/权限不同， 为了存放文件所需数据，需要对分区格式化，以成为操作系统能利用的文件系统格式。<br>文件系统把两部分数据存在不同的块， 权限和属性放置到inode，实际数据放置到data block中。还有个超级块记录整个文件系统的整体信息。包括inode和block总量、使用量、剩余量。三个数据意义：<br>super block：记录整个文件系统的整体信息。包括inode和block总量、使用量、剩余量，以及文件系统的格式和相关信息等<br>inode：记录文件属性，一个文件占用一个inode，同时记录此文件数据所在的block号码<br>block：实际记录文件内容，文件太大时，占用几个block<br>索引式文件系统<br>ext2 block 限制 1、block大小与数量格式化完成后不能改变。2、每个block最多放置一个文件数据3、文件大于一个block，占用多个block4、文件小于block，那block剩余空间也不能使用<br>inodetable: 包括： 访问模式(rwx) owner group 大小 atime ctime mtime 特殊标志如SUID 真正指向内容（block) 特色：inode 大小固定为128bytes，每个文件只有一个inode，文件系统创建文件数量与inode数量有关、系统先找到inode并分析权限然后确认是否打开block   inode记录block包括12个直接，1个间接，1个三间接<br>superblock：包含：block inode总量，未使用block inode总量 block inode 大小 文件系统的一些时间信息 validbit 如果文件系统已挂载为0 未挂载为1 文件系统说明 块对照表（可以找到哪些block是空的） inode对照表（找到哪些inode是空的）<br>df：可以调出目前挂载的设备<br>dumpe2fs [-bh] 设备文件名<br>二、与目录数关系<br>新建目录时会分配一个inode和至少一个block<br>ll -i 可以查看incode号码<br>目录几乎都是1024的倍数。 因为block数量都是1k 2k 4k<br>新建文件 会分配一个inode 和相对于该文件大小的block文件   文件名记录在目录的block 读取文件先经过目录的inode和block 然后经过文件的inode block<br>三、挂载 将文件系统与目录树结合的操作称为挂载。 挂载点一定是目录，该目录为文件系统的入口。<br>四、Linux支持的文件系统与VFS<br>ls -l /lib/modules/$(uname -r)/kernel/fs  查看当前Linux支持哪些文件系统<br>cat /proc/filesystems  已经加载到内存支持的文件系统<br>Linux通过VFS（Virtual Filesystem Switch）的内核功能读取文件系统<br>五、磁盘与目录的容量<br>df 列出文件系统的整体磁盘使用量 df [-ahikHTm] -a：所有文件系统 -k：以kb容量显示 -m：以mb容量 -h：以较易阅读的GB MB KB自行展示 -H：以M＝1000k进位方式 -T：列出文件系统名称 -i：不用硬盘容量，以inode数量现实<br>du 评估文件系统磁盘使用量（常用于评估目录所占容量）[-ahskm] -a：所有文件 -h：以较易阅读根式 -s：列出总量，不列出每个目录 -S：不包括目录下的总计 -k：以kb列出 -m：以mb列出<br>六、连接文件 ln<br>hard link 只是在某个目录下新建一条文件名连接到某inode号码的关联记录。 只是在某个目录下的block多写入一个关联数据。 特点：不能跨文件系统，不能连接到目录。<br>symbolic link 是创建一个独立的文件，这个文件会让数据的读取指向它连接的那个文件的文件名。<br>ln [-sf] 源文件 目标文件  不加任何参数就是硬连接， 加-s就是软连接。 -f 如果目标文件存在，主动将目标文件删除后创建<br>七、磁盘分区、格式化、检验与挂载<br>分区：命令 fdisk [-l]<br>格式化磁盘：mkfs (make file system) 例： mkfs -t ext3 分区  \\  mke2fs [-bicLj]<br>检验 fsck (file system check)  fsck [-tAayC(ext2/ext3额外-fd)] 文件系统 设备名称   其实是调用e2fsck<br>挂载  mount [-altnLo]<br>卸载 umountn [-fn] 设备文件名或挂载点<br>磁盘参数修改 mknod 设备文件名[bcp] [Major] [Minor]<br>八、swap的构建<br>步骤 1、fdisk 2、mkswap 3、swapon 四、free<br>free 查看内存使用情况</p>
<p>9 文件与文件系统的压缩与打包<br>一、压缩命令<br>.gz gzip 压缩过的文件 .bz2 bzip2压缩的文件 .tar tar打包的数据，没有压缩过 .tar.gz tar打包文件 经过gzip压缩 .tar.bz2 tar打包文件经过bzip2压缩<br>gzip [-cdtv#] -c 将数据输出到屏幕上 可通过数据流重定向处理 如 gzip -c index.php&gt;index.php.gz  -d 解压缩 -t 检测压缩文件一致性 有无错误 -v 可以显示出源文件/压缩文件的压缩比等信息 -#（-1 到 -9）压缩等级， -1最快 -9最慢 默认-6<br>zcat 读取gz压缩文件， 相当于解压后读取<br>bzip2 [-cdkzv#] -c 将数据输出到屏幕  -d 解压缩 -k保留原文件 -z 压缩的承诺书 -v 可以显示出源文件/压缩文件的压缩比等信息 -#（-1 到 -9）压缩等级， -1最快 -9最慢 默认-6<br>bzcat 读取bz2压缩文件<br>二、打包命令<br>tar [-ctxjzvfC] -c 新建打包文件 -t 查看文件有哪些文件 -x 解打包 -j 通过bzip2进行压缩 -z 通过gzip进行压缩 -f 被处理的文件名 -C 目录 解压缩可以指定 -p 保留原本权限和属性 —exclude＝FILE 不要将FILE打包  —newer 或 —newer-mtime=“2008/09/29” 比某个时刻新的文件<br>三、备份<br>dump [-Suvj] [-level(0-9)] [-f 备份文件] 待备份数据  -S 仅列出带备份数据需要多少磁盘 -u 将时间记录到/etc/dumpdateS -v 显示过程 -j 加入bizp2支持压缩 默认等级2 -(0-9) 等级 -f 后面接产生的文件 -W 列出/etc/fstab 具有dump设置的分区是否备份过<br>restore 恢复备份数据 [-tCirfhD] -t 查看含有什么重要数据 -C 与实际文件比较 -i 互动 可以还原部分文件 -r 整个文件系统还原<br>四、光盘写入<br>mkisofs  新建镜像文件<br>cdrecord 光盘刻录工具</p>
<p>10 vim 程序编辑器<br>vi使用<br>vi 分三种模式 一般模式 编辑模式 命令行模式<br>命令列表<br>①一般模式<br>移动光标<br>ctrl+f 屏幕向下移一页<br>ctrl+b 屏幕向上移一页<br>ctrl+d 屏幕向下移半页<br>ctrl+u 屏幕向上移半页</p>
<ul>
<li>光标移动到非空格符的下一行     - 光标移动到非空格符的上一行<br>20<space> 光标向右移这一行的20个字符<br>0或者home 移动到这一行的最前面<br>$或者end 移动到这一行的最后面<br>H 移动到屏幕最上方一行的第一个字符<br>M 移动到屏幕中央那一行的第一个字符<br>L 移动到屏幕最下方一行的第一个字符<br>G 移动到文件最后一行<br>20G 移动到这个文件的第20行<br>gg 相当于 1G<br>N<enter> 光标向下移动n行<br>查找与替换<br>/ 向下查找<br>? 向上查找<br>n 正向继续上一个查找<br>N 反向继续上一个查找<br>:n1,n2s/word1/word2/g  从n1行到n2行把word1替换为word2<br>:1,$s/word1/word2/g  从1行到最后一行把word1替换为word2<br>:1,$s/word1/word2/gc  从1行到最后一行把word1替换为word2，替换前提示确认<br>删除 复制 粘贴<br>x X x向后删除一个字符  X向前删除一个字符<br>10x 连续向后删除10个字符 10X 连续向前删除10个字符<br>dd 删除光标所在一行<br>20dd 删除光标所在这一行下20行<br>d1G 删除光标所在到第一行的数据<br>dG 删除光标所在到最后一行的数据<br>d$ 删除光标所在到该行最后一个字符<br>d0 删除光标所在到改行第一个字符<br>yy 复制光标所在第一行<br>20yy 复制光标向下的20行<br>y1G 复制光标所在到第一行的所有数据<br>yG 复制光标所在到最后一行的所有数据<br>y0 复制光标所在到该行第一个字符<br>y$ 复制光标所在到该行最后一个字符<br>p P p将复制的数据粘贴在光标下一行 P将复制在上一行<br>J 将光标所在行与下一行合成一行<br>c 重复删除多个数据 如向下删除10行 10cj<br>u 复原前一个操作<br>ctrl+r 重做上一个复原的<br>. 重做前一个操作<br>②编辑模式<br>i I  i 从目标所在插入 I 目前所在行的第一个非空格符插入<br>a A a 从光标所在的下一个字符开始插入 A 从光标所在行的最后一个字符处开始插入<br>o O o 光标所在下一行插入新一行 O 在光标上一行插入新的一行<br>r R r 替换光标所在的字符  R 一直替换光标所在的字符<br>esc 退出编辑模式<br>③命令模式<br>感叹号 ! 有强制的作用<br>:w 写入<br>:q 退出<br>:wq 保存后离开<br>ZZ 文件没有改动 不保存离开 变更 保存后离开<br>:w filename 保存为另一个文件filename<br>:r filename 读入filename文件的数据到光标后面<br>:n1, n2 w filename  把n1到n2的数据保存成filename这个文件<br>:! command 暂时离开vi 到命令模式下执行command<br>:set nu 现实行号<br>:set nonu 取消行号</enter></space></li>
</ul>
<p>命令备忘<br>man date    作用：查看date命令信息<br>info date    作用：查看date命令信息<br>shutdown -h now 立刻关机  shutdown -h +10 十分钟关机  shutdown -h 11:00  11点关机（24小时制）<br>chgrp usergroup1 index.php  作用：把index.php用户组改变为usergroup1组<br>chown user1 index.php  作用：把index.php所有者改为user1<br>chown user1:usergroup1 index.php  作用：把index.php所有者改为user1，用户组改为usergroup1<br>chmod 664 index.php  作用：把index.php权限修改为 -rw-rw-r—<br>chmod u=rwx,go=rx index.php  作用 把index.php权限设置为 -rwxr-xr-x<br>chmod a-x index.php  作用：把去掉所有人的可执行权限<br>cp .test .testcp    作用：将 .test 复制为 .testcp<br>touch test.php  作用：创建新的空文件test.php<br>cat test.php  作用：将test.php内容读出来<br>last 2016.07.08.asl 作用：读取数据格式文件， 比如操作日志<br>cd 作用 ：回主目录  同 cd ~<br>cd - 作用：切换回刚才的目录，<br>pwd -P 作用：如软链的时候获取真正的目录名称<br>mdkir -m 711 test 作用：创建权限为drwx—x—x的test文件夹<br>echo $PATH 作用：打印环境变量<br>PATH=“$PATH”:/test  作用：把test加入环境变量目录<br>basename /Users/chadli/Projects/local  作用 ：返回local<br>dirname /Users/chadli/Projects/local 作用：返回/Users/chadli/Projects<br>tail -fn +100 test.php 作用：打印test.php100行到页脚的数据  然后等待文件输入<br>head -n 20 test.php|tail -n 10 作用：获取test.php 11-20行的内容<br>ls -l —time=atime test.php  作用：获取test.php的access time<br>umask / umask -S  作用：查看当前用户默认权限<br>umask 022  作用：修改默认权限， u＝rwx g＝rx o=rx<br>file test.php 作用：返回test.php的文件属性  （结果 PHP script text）<br>df 作用：查看挂载的设备<br>ls -il  作用：查看文件的inode号码<br>ls -l /lib/modules/$(uname -r)/kernel/fs  作用：查看当前Linux支持哪些文件系统<br>cat /proc/filesystems  作用：已经加载到内存支持的文件系统<br>du 作用：查看当前目录下文件使用量<br>ln test.php test1.php  作用：将test1.php硬连接到test.php<br>ln -s test test1 作用：将test1软连接到test<br>free 作用：查看内存使用情况<br>gzip index.php 作用：压缩index.php 为 index.php.gz index.php不保留<br>gzip -c index.php&gt;index.php.gz 作用：压缩index.php 为 index.php.gz index.php保留<br>gzip -d index.php.gz 作用：解压缩index.php.gz<br>zcat index.php.gz 作用：查看index.php.gz内容<br>bzip2 -z index.php 作用：压缩index.php 为 index.php.bz2 index.php不保留<br>bzip2 -c index.php&gt;index.php.gz 作用：压缩index.php 为 index.php.bz2 index.php保留<br>bzip2 -d index.php.gz 作用：解压缩index.php.bz2<br>bzcat index.php.gz 作用：查看index.php.gz内容<br>tar -jcpv -f test.tar.bz2 test/  作用：把 test/ 打包压缩为 test.tar.bz2<br>tar -jtv -f test.bar.bz2  作用：查看test.tar.bz2的内容<br>tar -jxv -f test.bar.bz2 -C test/  作用：把test.bar.bz2的内容解压缩到test下<br>tar -jxv -f test.bar.bz | grep ‘index.php’ 作用：只解压缩index.php文件</p>
<p>11.认识与学习bash<br>必须通过shell讲我们输入的命令与内核通信，好让内核可以控制硬件来工作。<br>只要能操作应用程序的接口都叫shell<br>Linux使用的shell Bourne Again Shell  ===== bash<br>系统上合法的shell写入 /etc/shells 因为系统某些服务在运行过程中，回去检查用户能够使用的shells， 这些查询就是借助/etx/shell这个文件夹<br>别名设置 命令输入 alias lm=‘ls -al’<br>使用type命令确认命令是否bash内置 使用方法：type [-tpa] name  如：type  cd<br>命令的转义符\   当想换行但不直接执行命令时， 输入\回车<br>echo $PATH 输出环境变量<br>设置环境变量  myname=ChadLi<br>设置规则 ：<br>1、变量与变量内容=号连接，<br>2 等号两边不能有空格<br>3 变量名称只能是英文字母与数字切开头字符不能是数字<br>4 变量内容若有空格可使用双引号活单引号将变量内容结合起来，双引号的特殊字符如$可以保有原有的特性，单引号的特殊字符仅为一般字符， （PHP的字符串定义规则）<br>5 可以使用转义符“\”将特殊符号如（enter $ \ 空格 !）变成一般字符<br>6 命令中 如果需要其他命令提供的信息，使用<code>命令</code> 或 $(命令) 如 version=$(uname-r)<br>7 增加变量内容时 使用$变量名称或${变量}累加内容  如 PATH=“$PATH”:/home/bin<br>8 若该变量需要再其他子进程执行，则需要以export使变量变成环境变量 如 export PATH<br>取消变量的方法是  unset 变量名称<br>如何进入到目前内核的模块目录  cd /lib/modules/<code>uname -r</code>/kernel<br>`之内的命令会被先执行，执行结果作为外部输入信息<br>用env 查看环境变量与常见环境变量说明 environment的缩写<br>返回信息<br>HOME 用户主文件夹<br>SHELL 目前环境使用的哪个程序  默认/bin/bash<br>HISTSIZE 设置历史命令条数<br>MAIL 使用mail命令收信时会读取的邮件信箱地址<br>PATH 执行文件查找的路径 路径间用冒号:连接<br>LANG 语系数据<br>RANDOM /dev/random 可以通过这个随机述文件的变量$RANDOM 来取得随机值 介于0~32767 echo $RANDOM 就会随机取出一个值</p>
<p>set查看所有变量<br>PS1 命令提示符<br>/d 显示星期月日  如Mon Feb 2<br>\H 完整的主机名 如 <a href="http://www.cli.com" target="_blank" rel="noopener">www.cli.com</a><br>\h 仅取第一个小数点钱的名字 如www<br>\t 时间 24小时的HH:MM:SS<br>\T 时间 12小时的HH:MM:SS<br>\A 时间 24小时的HH:MM<br>\@时间 12小时的 am/pm<br>\u 当前账户<br>\v BASH的版本<br>\w 完整的工作目录 根目录起  主文件夹以~替换<br>\W basename取得工作目录名称<br># 执行的第几个命令<br>\$ 提示符  root为# 否则为$</p>
<p>$ 本shell的PID  $本身也是一个变量  要输出 shell的PID  echo $$</p>
<p>? 上个执行命令的回传码  正常执行返回值0   错误返回错误代码 输出  echo $?</p>
<p>OSTYPE HOSTTYPE MACHTYPE 主机硬件 内核 等级</p>
<p>export 自定义变量转成环境变量<br>取得一个bash后，bash就是一个独立的进程。</p>
<p>11.2.4 影响现实结果的语系变量<br>查看所有支持语系  locale -a<br>整体系统默认的语系定义一般再/etc/sysconfig/i18n</p>
<p>11.2.5 变量的有效范围<br>环境变量被子进程引用的原因<br>1、启动一个shell，操作系统会分配一个记忆块给shell用，此内存内的变量可以让子进程取用<br>2、当父进程利用export功能，可以让自定义变量的内容写到记忆块<br>3、加载另一个shell（启动子进程），子shell可以将父shell的环境变量所在的记忆块导入自己的环境变量</p>
<p>11.2.6 变量键盘读取、数组与声明<br>read 读取键盘输入的变量<br>-p 可以接提示符<br>-t 接等待的秒数</p>
<p>declare / typeset 声明变量的类型<br>declare -aixr variable  用+可以进行取消操作<br>-a variable 设置为array<br>-i 设置为整型数字<br>-x 和export一样，把变量设置为环境变量<br>-r 设置为只读，不能被更改，也不能重设<br>变量类型默认为字符串，如果没有定义变量类型 1+2 会被认为是字符串而不是计算式<br>bash的变量最多能支持到整型</p>
<p>数组类型变量<br>设置方式 var[1]=test   读取 ${var[1]}</p>
<p>11.2.7 与文件系统及程序的限制关系<br>ulimit<br>-H 严格的限制， 不能超过这个数字<br>-S 警告限制，可以超过，超过后会有警告<br>-a 不接受任何参数，列出所有限制<br>-c 系统发生错误后，系统可能会将内存里的信息记录到文件<br>-f shell可以创建的最大文件容量<br>-d 进程可以使用的最大断裂内存<br>-l 可用于锁定的内存量<br>-t 可使用的最大CPU时间<br>-u 单一用户可以使用的最大进程数量</p>
<p>11.2.8 变量内容的删除 替代 替换<br>删除  echo ${variable#/<em>kerberos/bin:} 说明 ${variable(变量名称)#(从变量内容最前面开始向右删除，仅删除最短符合规则的那个)/</em>kerberos/bin:} ## 最长的那个<br>%从后往前删除 %%最长符合<br>替换  echo ${path/sbin/SBIN} 第一个sbin替换为SBIN  echo ${path//sbin/SBIN} 所有sbin替换为SBIN<br>总结<br>${变量#关键字}    若变量内容从头开始的数组符合“关键字”，则将符合的最短数据删除<br>${变量##关键字}    若变量内容从头开始的数组符合“关键字”，则将符合的最长数据删除<br>${变量%关键字}    若变量内容从尾向前的数组符合“关键字”，则将符合的最短数据删除<br>${变量%%关键字}    若变量内容从尾向前的数组符合“关键字”，则将符合的最长数据删除<br>${变量/旧字符串/新字符串}    如果变量内容符合旧字符串，则第一个旧字符串被新字符串替换<br>${变量//旧字符串/新字符串}    如果变量内容符合旧字符串，则全部旧字符串被新字符串替换</p>
<p>变量设置生效对应表<br>变量设置方式                str没有设置                str设置为空字符串                str已设置非为空字符串<br>var={$str-expr}            var=expr                    var=                            var=$str<br>var={$str:-expr}            var=expr                    var=expr                        var=$str<br>var={$str+expr}            var=                        var=expr                        var=expr<br>var={$str:+expr}            var=                        var=                            var=expr<br>var={$str=expr}            var=    expr str=expr            str 不变 var=                    str 不变 var=$str<br>var={$str:=expr}            var=    expr str=expr            var=    expr str=expr                str 不变 var=$str<br>var={$str?expr}            expr输出至stderr            var=                            var=str<br>var={$str:?expr}            expr输出至stderr            expr输出至stderr                var=str</p>
<p>11.3 命令别名与历史命令<br>11.3.1 命令别名设置 alias  unalias<br>命令别名和变量的不同， 命令别名是创建一个新命令，可以直接执行，变量需要使用类似echo才能调用</p>
<p>11.3.2 历史命令 history<br>history<br>n 数字，列出最近的n条命令行<br>-c 把目前的shell所有history清楚<br>-a 将目前新增的history命令新增如histfiles中， 没有加histfiles， 默认写入 ~/.bash_history<br>-r 将histfiles的内容读到目前shell的history<br>-w 将目前的history记忆内容写入histfiles</p>
<p>!! 执行上一个命令<br>!n 执行第n个命令<br>!vi  执行上一个开头是vi的命令行</p>
<p>11.4 Bash Shell的操作环境<br>11.4.1 路径与命令查找顺序<br>命令运行的顺序<br>1、以相对/绝对路径执行命令 例如 /bin/ls  或 ./ls<br>2、由 alias 找到该命令来执行<br>3、由bash 内置的(builtin)命令来执行<br>4、通过$PATH这个变量的顺序找到的第一个命令来执行<br>type -a ls 查询</p>
<p>11.4.2 bash 的登录与欢迎信息<br>登录信息写在 /etc/issue<br>\d 本地段时间 日期<br>\l 现实第几个终端机接口<br>\m 现实硬件等级<br>\n 显示主机网络名称<br>\o 现实 domain name<br>\r 现实系统版本  相当于 uname -r<br>\t 显示本地段时间 时间<br>etc/issue.net  Telnet连接到主机时展示的欢迎</p>
<p>11.4.3 base的环境配置文件<br>登录分为 login non-login shell<br>bash 环境配置文件<br>/etc/profile<br>PATH 依据UID决定 PATH 变量要不要含有sbin的系统命令目录<br>MAIL 依据账户设置用户的mailbox 到/var/spool/mail/账户号<br>USER 根据用户账号设置变量内容<br>HOSTNAME 依据主机的hostname 命令决定变量内容<br>HISTSIZE 历史命令记录条数<br>profile调用 /etc/inputrc  /etc/profile.d/*.sh   /etc/sysconfig/i18n<br>个人环境配置<br>~/.bash_profile   ~./bash_login ~/.profile     依次查找，找到后不再查找<br>source 配置名   设置了新环境变量后可以用source 或者小数点(.) 重新加载</p>
<p>11.4.4 终端机的环境设置 stty set<br>stty -a<br>-a 将所有的stty参数列出来<br>eof end of file 代表结束输入<br>erase 向后删除自字符<br>intr 送出一个interrupt（中断）的信号给目前正在运行的程序<br>kill 删除在目前命令行的所有文字<br>quit 送出一个quit的信号给目前正在运行的进程<br>start 某个进程停止后，重新启动他的输出<br>stop 停止目前屏幕的输出<br>susp 送出一个terminal stop的信号给正在运行的进程<br>使用stty 命令设置 环境设置， 如 stty erase ^h 这样以后删除键就改成了ctrl + h<br>set还可以设置整个命令输入/输出的环境<br>一些其他的按键设置功能，存储在 /etc/inputrc<br>常用组合键 默认Ctrl +<br>C 终止目前的命令 D 输入结束 M 就是Enter S 暂停屏幕的输出 Q 恢复屏幕的输出 U 提示符下将整行命令删除 Z 暂停目前的命令</p>
<p>11.4.5 通配符与特殊符号</p>
<ul>
<li>代表0到无穷个任意字符<br>？代表一定有一个任意字符<br>[]同样代表一定有一个中括号内的字符（非任意字符）。<br>[-]如有减号在中括号内，表示编码顺序内到所有字符<br>[^]如有中括内到第一个字符为指数符号^，表示愿向选择，<br>#批注符号 后面数据不执行<br>\转译符号 将 特殊字符或通配符 还原成一般字符<br>| 管道 分割两个管道命令的界定<br>; 连续命令执行分隔符，连续性命令的界定<br>~ 用户主文件夹<br>$ 变量前导符<br>&amp; 作业控制 将命令变成背景下工作<br>！逻辑意义上的非的意思<br>/ 目录符号，路径分隔<blockquote>
<p>, &gt;&gt; 数据流重定向 输出导向，分表是替换。累加<br>&lt;,&lt;&lt; 数据流重定向 输入导向<br>‘’ 单引号，不具有变量置换的功能<br>”” 具有变量置换的功能<br><code></code> 可执行的命令 也可以使用$()<br>() 中间为子shell执行的开始和结束<br>{} 在中间为命令块的组合</p>
</blockquote>
</li>
</ul>
<p>11.5<br>数据流重定向<br>11.5.1<br>standard output 与 standard error output  标准输出是命令正常执行回传的信息，错误输出是命令执行失败后回传的错误信息<br>数据流重定向可以把输出传送到其他的文件和设备<br>标准输入 0 使用 &lt;  或 &lt;&lt;<br>标准输出 1 使用 &gt; 或 &gt;&gt;<br>标准错误输出 2 使用 2&gt;或2&gt;&gt;<br>1&gt; 以覆盖的方法将正确的数据输出到指定的文件或设备<br>1&gt;&gt; 以累加的方法将正确的数据输出到指定的文件或设备<br>2&gt; 以覆盖的方法将错误的数据输出到指定的文件或设备<br>2&gt;&gt; 以累加的方法将错误的数据输出到指定的文件或设备<br>如：find /home -name .bashrc &gt; list_right 2 &gt; list_error<br>/dev/null 垃圾黑洞设备与特殊写法<br>find /hoem -name .bashrc 2&gt; /dev/null<br>正确错误同时写入 find /home -name .bashrc &gt; list 2&gt;&amp;1.或者 find /home -name .bashrc &amp;&gt; list<br>&lt; &lt;&lt; 原来需要键盘输入的数据改由文件内容替代<br>cat创建文件 cat &gt; catfile.         输入，或者复制某个文件内容  cat &gt; catfile &lt; ~/.bashrc</p>
<p>11.5.2 命令执行的判断依据；，&amp;&amp; ||<br>一次输入多个命令方法：cmd;cmd.不考虑命令相关性<br>Cmd1&amp;&amp;cmd2 若cmd1执行完毕且正确执行cmd2 ，错误不执行cmd2<br>cmd1 || cmd2 若cmd1执行完毕且正确不执行cmd2，错误则执行cmd2<br>创建/tmp/abc/hehe，但是不知道abc是否存在，可以使用命令<br> ls /tmp/abc || mkdir /tmp/abc &amp;&amp; touch /tmp/abc/hehe<br>命令是一个接一个执行，因此如果真要使用判断，那么这个&amp;&amp;与||的顺序就不能搞错</p>
<p>11.6 管道命令<br>管道只能处理前面一个命令传来的正确信息，不能处理错误信息<br>每个管道后面第一个数据必定是命令，并且是能接受standard input的数据<br>11.6.1 选取命令cut grep<br>cut -d f c<br>-d 后面接分隔符号与-f一起使用<br>-f 依据-d的分隔符号将一段信息切割成数段，用-f取出来第几段<br>-c 以字符的单位取出固定字符区间<br>如：cut $PATH | cut -d ’;’ - f 3,5<br>export | cut -c 12-<br>grep 是分析一行信息，如果有我们需要的信息，就拿出来<br> grep [-acinv] [—color=auto] ’查找字符串‘ filename</p>
<p>11.6.2 排序命令 sort wc.uniq<br> cat /etc/passwd | sort-t ’;’ -k 3<br>重复数据仅展示一个 last | cut -d ’ ’ -f 1 | sort | uniq -c<br>wc 列出文件多少字多少行多少字符<br>-l 列出行-w 列出多少字-m 列出多少字符</p>
<p>11.6.3 双向重定向 tee<br>tee 可以把输出转存到文件，也可以同时打印到屏幕</p>
<p>11.6.4 字符转换命令 tr col join paste expand<br>tr 用来删除一段信息中的文，或者进行文字信息替换， 支持正则表达式<br>last | tr ’[a-z]’ ’[A-Z]<br>col 可以将tab转换为空格，也可以将man page转存为纯文件为保健<br>join 主要将两个文件当中有相同数据的那一行加在一起，使用join前需要处理的文件应该事先经过排序，否则有些对比项目就会被略过<br>paste 将两行贴在一起，且中间以tab键隔开。<br>paste -  表示来自standardinput的数据<br>expand就是将tab转换为空格。 unexpand 将空格转成tab</p>
<p>11.6.5 切割命令split<br>split 把大文件切割成为小文件。</p>
<p>11.6.6 参数代换 xargs<br>xargs 产生某个命令参数的意思。很多命令不支持管道命令，我们可以通过xargs 来提供命令饮用startard input 只用</p>
<p>11.6.7 关于减号 - 的用途<br>管道命令中经常使用前一个命令的stdout作为这次的stdin，stdin和stdout 可以用-代替</p>
<p>12 正则表达式与文件格式化处理<br>12.2.1特殊符号[:album:] 0-9 A-Z a-z 等<br>11.2.5 sed<br>nl /etc/passwd | sed ’2, 5d’ 查找后删除第2- 5行</p>
<p>12.4 文件等格式化淤相关处理<br>12.4.1 格式化打印printf<br>printf ‘打印内容’  实际内容<br>Printf ’%s\t %s\t \n’ $(cat printf.txt)<br>printf 还以为依据ASCII的数字与图形对应显示数据<br>12.4.2 awk好用的数据处理工具<br>运行模式 awk ’条件类型1{动作1} 条件类型2{动作2}’ filename<br> last -n 5 | awk ’{print $1 ”\t” $3}’<br>awk 是以行为一次处理的单位，以字段为最小的处理单位<br>所有awk的动作即在{}内的动作，如果有需要多个命令辅助，可利用分毫间隔，或者直接以enter按键来隔开每个命令<br>逻辑运算当中，如果是等于的情况，使用两个等号==<br>格式化输出时，在printf的格式设置中，务必加上\n  才能进行换行<br>与bash  shell不同，awk当中，变量可以直接使用，不用加上$符号</p>
<p>12.4.3 文件比较工具<br>diff 以行为比较多单位<br>diff /etc/test/  /etc/test1/ 比较目录<br>cmp.主要比较两个文件 主要利用字节为单位比较<br>patch 可以把对比文件写入到老文件<br>Patch -p0 &lt; passwd.patch</p>
<p>12.4.4 文件打印准备 pr</p>
<p>13 学习shell script<br>13.1 什么是shell script<br>shell script 就是利用shell的功能写的一个程序，这个程序是使用纯文本文件，将一些shell的语法与命令（含外部命令）写在里面，搭配正则表达式、管道命令与数据流重定向等功能，以达到我们所想要的目的。<br>script的特点<br>1、命令的执行是从上往下，从左往右的分析与执行<br>2、命令的执行，命令 参数间的空白会被忽略<br>3、空白行也被忽略掉，tab键所得的空白也被同样视为空格键<br>4、如果读取到一个enter符号，就尝试开始执行该行命令<br>5、如果一行内容太多，可以使用\enter 扩展到下一行<br>6、#作为批注，任何加在#后面的数据将全部视为批注文字被忽略</p>
<p>#!/bin/bash 声明这个script使用的shell名称<br>13.2.2 script  的执行方式区别 source shscript  ./scirpt<br>脚本还可以通过source或者小数点. 执行<br>1 用直接执行的方式执行 会用新的bash环境执行脚本命令<br>2 用source执行，在父进程中执行，也是为什么改了配置用source可以直接生效</p>
<p>13.3 善用判断式<br>13.3.1 利用test命令的测试功能</p>
<p>13.3.2 使用判断符号[]来进行数据判断<br>1 、中括号内的每个组件需要有空格符来分隔<br>2、中括号内的变量最好都以双引号括号起来<br>3、在中括号内的常量最好都以单或双引号括起来</p>
<p>13.3.3 shell scirpt 的默认变量 $0 $1<br>执行的脚本文件名 $0 第一个参数 就是$1<br>特殊变量<br>$# 后接入的参数个数<br>$@ 代表 “$1” “$2” 之意，每个变量都是独立的，用双引号括起来<br>$* 代表”$1c$2$3” 之意，c为分隔符，默认为空格键<br>shift 造成参数变量号码偏移<br>shift 后面跟数字表示拿掉几个变量</p>
<p>13.4 条件判断式<br>13.4.1 if then<br>if[条件判断式] ; then<br>fi<br>多重判断<br>if[条件判断式] ; then<br>else<br>fi<br>if[条件判断式] ; then<br>elif[条件判断式] ; then<br>else<br>fi<br>13.4.2 利用case esac判断<br>case $变量名称 in<br>“第一个变量内容”)<br>程序段<br>;;<br>“第二个变量内容”)<br>程序段<br>;;<br>*)<br>exit1<br>;;<br>esac</p>
<p>13.4.3 利用function功能<br>函数可以在shell script当中做出一个类似自定义执行命令的东西，可以简化我们的很多的程序代码。<br>因为shell script是从上而下，从左而右执行，所以function设置一定要在程序的最前面<br>function 内置变量和shell script类似，函数名称代表示 $0 后续的变量也是以 $1 $2 代替</p>
<p>13.5 循环 loop<br>13.5.1 while do done ， until do done   不定循环<br>两种不定循环的方式<br>while [condition]<br>do<br>程序段落<br>done</p>
<p>until [condition]<br>do<br>程序段落<br>done</p>
<p>13.5.2 for do done 固定循环<br>for var in con1 con2 con3<br>do<br>程序段<br>done<br>for var in $(seq 1 100) seq 代表后面接的两个数字值是一直连续的</p>
<p>13.5.3 for do done 的数值处理<br>for((初始值; 限制值; 执行步长))<br>do<br>程序段<br>done</p>
<p>13.6 shell script 的追踪与调试<br>不执行script判断是否有问题<br>sh [-nvx] scripts.sh</p>
<p>14 Linux 账户管理与ACL权限设置<br>14.1 Linux的账号与用户组<br>14.1.1 用户标示符 UID 与GID<br>Linux 主机不会直接认识账户名称，仅认识ID，ID与账号的对应关系在/etc/passwd<br>每个登录用户至少取得两个ID，用户ID UID， 用户组ID GID</p>
<p>14.1.2 用户账户<br>输入账号密码后，系统处理：<br>1 先找寻 /etc/passwd 里面是否有你输入的账号，没有就退出，有的话将该账号对应的UID与GID读出来，另外，该账号的主文件夹与shell设置一起读出来<br>2 核对密码表，Linux会进入/etc/shadow 里面找出对应的账号与UID，然后核对一下你输入的密码与里面的密码是否相符<br>3 一切OK，进入shell 控管阶段<br>/etc/passwd 文件结构<br>每一行代表一个账户，每一行用”:”分割，共七个字段。分别是 1账户名称 2 密码 3UID （0 系统管理员 1-499 系统账户 500-65535 可登录账户）4GID /etc/group 5 用户信息说明列 6 主文件夹 7Shell<br>/etc/shadow 文件结构<br>同样以”:” 分隔符，有九个字段。1账户名称 2密码 3最近更改密码的日期 4密码不可被更动的天数 5 密码需要重新更改的天数 6 密码需要更改期限前的警告天数 7 密码过期后的账号宽限时间 8 账号失效日期 9 保留 </p>
<p>14.1.3 有效与初始用户组：groups newgrp<br>/etc/group 文件结构<br>每一行代表一个组 “:” 分隔 四列 1 用户组名称 2 用户组密码 3 GID 4 此用户组支持的账号名称<br>初始用户组，用户登录系统，立刻就拥有这个用户组的相关权限<br>groups 有效与支持用户组的查看<br>groups 知道我所有支持的用户组，第一个输出的用户组即为有效用户组<br>newgrp 有效用户组的切换<br>想要切换的用户组必须是已经有支持的用户组  如 newgrp users<br>/etc/gshadow<br>“:” 分隔，几乎与/etc/group 一样， 第二个字段密码列如果上面是”!” 表示该用户组不具有用户组管理员。四个字段意义 1用户组名 2密码列 3 用户组管理员账户 4该用户组的所属账户</p>
<p>14.2 账户管理<br>14.2.1 新增与删除用户 useradd 相关配置文件 passwd usermod userdel<br>useradd [-u UID] [-g 初始用户组] [-G 次要用户组] [-mM] [-c 说明栏] [-d 主文件夹绝对路径] [-s shell] 用户账号名<br>系统已经规定好非常多默认值，可以简单用useradd 账号创建，这些默认值主要帮我们处理<br>1在/etc/passwd 创建一行与账号相关的数据，包括创建 UID/GID/主文件夹等;<br>2在/etc/shadow里面讲此账号的密码相关参数填入，但是尚未有密码<br>3在/etc/group 加入一个与账号名称一模一样的组名<br>4在/home下面创建一个与账号同名的目录作为用户主文件夹，切权限为700<br>系统账号默认不会主动创建主文件夹<br>useradd创建用户账号会更改几个文件<br>1 用户账号与密码参数方面的文件 /etc/passwd  /etc/shadow<br>2 用户组相关方面的文件 /etc/group /etc/gshadow<br>3 用户的主文件夹 /home/账号名称<br>useradd 参考文件<br>useradd -D 查看默认值<br>这个数据是从 /etc/default/useradd 调用出来<br>两种用户组机制<br>私有用户组机制 系统创建一个和账户一样的用户组给用户作为初始用户组<br>公共用户组机制<br>centOS 是私有用户组机制<br>useradd 参考 /etc/default/useradd  /etc/login.defs /etc/skel/*<br>passwd<br>passwd [–stdin]  直接输入是修改自己的密码   要帮一般账号新建密码需要使用 passwd 账号<br>echo ‘mima’ | passwd –stdin vbird2<br>chage [-ldEImMW] 查看详细密码参数<br>usemod 进行账户微调 usermod [-cdegGlsuLU] username<br>userdel 删除用户相关数据<br>最好删除前 先 find / -user username 查找属于username的文件</p>
<p>14.2.2 用户功能<br>finger 查阅用户信息 finger [-s] username<br>chfn 有点 change [-foph] 账户名<br>chsh change shell 的简写 chsh [-ls]<br>id 查询某人或者自己相关UID/GID 信息 id username</p>
<p>14.2.3 新增与删除用户组<br>用户组的内容与两个文件有关  /etc/group   /etc/gshadow<br>groupadd [-g gid] [-r] 用户组名<br>groupmod 进行group相关参数修改<br>groupdel 删除用户组<br> gpasswd 用户组管理员功能</p>
<p>14.3  主机的具体权限规划 ACL 的使用<br>ACL access control list<br>acl 可以针对单一用户单一文件 目录进行 rwx的权限设置<br>它主要可以针对下面几个项目<br>1 用户user<br>2 用户组  group<br>3 默认属性 mask</p>
<p>14.3.3 acl 的设置技巧 getfacl setfacl<br>getfacl 取得某个文件/目录的acl设置项目<br>setfacl 设置某个文件/目录的acl 规定 u:用户:权限  设置了acl权限部分会多一个+  d可以文件夹继承<br>mask  用户与用户组的权限必须要存在于mask的权限设置范围内才会生效，此即有效权限</p>
<p>14.4 用户身份切换<br>14.4.1  su 最简单的身份切换命令 ，可以进行任何身份切换<br>su [-lm] [-c 命令] [username]<br>要完整的切换到新用户的环境，必须使用 su -username 或 su -l username ，才会联通PATH/USER/MAIL 等变量都切换到新用户环境<br>如果只想执行一次root命令 用 su - -c “命令串”<br>使用root切换到任何用户，不需要输入用户密码</p>
<p>14.4.2 sudo<br> 只有/etc/sudoers 内的用户可以执行sudo。<br>sudo [-b] [-u 新用户账户]<br>sudo 执行流程<br>1 当用户执行sudo，系统于 /etc/sudoers 文件中查找该用户是否有执行sudo的权限<br>2 若用户具有可执行sudo的权限后，让用户输入用户自己的密码来确认<br>3 若密码输入成功，变开始进行sudo后续的命令（但root执行sudo时不需要输入密码）<br>4 若切换的身份与执行者身份相同，也不需要输入密码<br>visudo 与/etc/sudoers<br>root 使用visudo 修改/etc/sudoers<br>visudo只是单纯用vi 将/etc/sudoers 调出来<br>/etc/sudoers 四个参数意义<br>1 用户账户 系统的哪个账号可以使用sudo，默认root<br>2 登陆者的来源主机名：这个账号由哪台主机连接到本Linux主机，意思是这个账号可能是由哪一台网络主机连接过来的，这个设置值可以指定客户端计算机（信任用户的意思）。默认值root可来自任何一台网络主机<br>3 可切换的身份，这个账号可以切换成什么身份来执行后续的命令，默认root可以切换成任何人<br>4可执行的命令 这个命令请务必使用绝对路径编写。默认root可以切换任何身份进行任何命令。</p>
<p>利用用户组以及免密码功能处理visudo<br>%wheel   NOPASSWD 免密<br>有限制的命令操作 限制动作 ! 不可执行<br>设置别名 可以设置命令别名 账号别名 主机别名（别名要大写） 统一设置<br>sudo时间间隔，五分钟内再次执行sudo不需要输入密码<br>sudo 搭配su  这样输入自己的密码就可以变成root身份了</p>
<p>14.5 用户的特殊shell与PAM<br>14.5.1 特殊的shell /sbin/nologin<br>/etc/nologin.txt返回不能登录的原因。</p>
<p>14.5.2 PAM 模块<br>PAM Pluggable Authentication Modules   嵌入式验证模块，可以说是一套应用程序接口，提供了一连串验证机制，只要用户将验证阶段的需求高速PAM，PAM就能回报用户的验证结果。</p>
<p>14.5.3 PAM模块设置语法<br>PAM通过一个与程序想通文件名的配置文件来进行一连串的认证分析需求。<br>执行passwd后，调用PAM的流程是<br>1 用户执行 /user/bin/passwd ，并输入密码<br>2 passwd 调用PAM模块验证<br>3 PAM模块会到/etc/pam.d/中找寻与程序同名的配置文件<br>4 依据/etc/pam.d/passwd 内的设置，引用相关的PAM模块逐步进行验证分析<br>5 将验证结果回传到passwd这个程序<br>6 passwd 会依据PAM回传的结果决定下一个操作<br>验证每一行区分三个字段  验证类别  中智标准 PAM模块与该模块参数<br>验证类型 有四种  分别是<br>1auth authentication的缩写，用来校验用户身份验证，这种类型通常需要密码校验。<br>2account 大部分是进行授权，主要校验用户是否有正确权限<br>3session 这次登录期间PAM给予的环境设置。通常记录用户登录与注销的信息。<br>4password 用于提供验证的修订工作，修改/更改密码<br>通常四个验证类型是有顺序的<br>第二个字段  验证的控制标志 control flag  验证通过的标准<br>管控验证的放行方式 分为四种控制方式<br>1required 验证成功带有success的标志，失败则带有failure的标志。但不论成功失败都会继续后续的验证流程。有利于数据的登录日志。<br>2requisite 验证失败立刻回报原程序failure的标志。并且终止后续的验证流程。验证成功则带有success的标志并继续后续的验证流程。<br>3sufficient 验证成功立刻回传success给原程序，终止后续的验证，验证失败则带有failure的标志继续后续验证流程。与requisite相反<br>4optional 显示信息，不用来验证。</p>
<p>14.5.4 常用模块简介<br>/etc/pam.d/8 每个程序个别的PAM配置文件<br>/lib/security/<em> PAM 模块文件的实际放置目录<br>/etc/security/</em> 其他PAM环境的配置文件<br>/usr/share/doc/pam-*/ 详细的PAM 说明文件<br>pam_securetty.so 限制系统管理员root只能从安全的终端机登录<br>pam_nologin.so 限制一般用户能否登录主机<br>pam_selinux.so 针对程序进行详细管理权限<br>pam_console.so<br>pam_loginuid.so 验证UID真的是我们需要的数值<br>pam_env.so 设置环境变量的一个模块<br>pam_unix.so<br>pam_cracklib.so 检测密码的强度包括密码是否在字典中，密码输入几次就断掉此次连接等<br>pam_limits.so<br>Login 的PAM验证机制流程<br>1 验证阶段  经过pam_securetty.so pam_env.so pam_UNIx.so pam－succee_if.so<br>2授权阶段pam_nologin.so pam_UNIX  pam_succeed_if.so<br>3 密码阶段pam_cracklib.so pam_UNIX.so<br>4 会议记录pam_eslinux.so 暂时关闭SELiunx pam_limits.so pam_loginuid.so<br>14.5.5 其他相关文件<br>limits.conf </p>
<p>14.6 Linux主机上的用户信息传递<br>14.6.1 查询用户: w who last lastlog</p>
<p>14.6.2 用户对谈: write mesg wall<br>write 用户账户 [用户所在终端接口]<br>mesg n 不接受任何消息<br>wall对系统上的所有用户传递信息（广播）</p>
<p>14.6.3 用户邮件信箱 mail<br>mail username@locahost -s “邮件标题”  &lt; filename 结束时最后一行输入小数点 . 即可<br>可以使用 &lt;将文件内容输入</p>
<p>14.7 手动新增用户<br>14.7.1 一些检查工具<br>pwck 检查/etc/passwd 这个帐号配置文件内的信息，与实际的主文件夹是否存在等信息，还可以比较/etc/passwd /etc/shadow 的信息是否一致<br>用户组检查grpck<br>pwconv 将/etc/passwd内的帐号与密码移动到/etc/shadow中<br>pwunconv 将/etc/shadow 内的密码列数据写回/etc/passwd<br>chpasswd 读入未加密的密码，经过加密后，将加密的信息写入/etc/shadow echo “username:password” | chpasswd -m</p>
<p>14.7.2 特殊帐号（如纯数字帐号）的手工新建<br>手动创建流程<br>1 新建所需要的用户组  vi /etc/group<br>2 将/etc/group 与/etc/gshadow 同步(grpconv)<br>3 新建帐号的各个属性 vi /etc/passwd<br>4 将/etc/passwd 与/etc/shadow 同步(pwconv)<br>5 新建该帐号的密码 (passwd accountname)<br>6 新建用户主文件夹 (cp -a/etc/skel /home/accountname)<br>7 更改用户主文件夹属性 (chown -R accountname group/home/accountname)</p>
<p>15 磁盘配额(Quota)与高级文件系统管理<br>15.1磁盘配额(Quota)的应用与实践<br>15.1.1 什么是quota<br>针对www server  每个人的网页容量限制<br>针对mail server 每个人的 邮件空间限制<br>针对file server 每个人的最大可用网络硬盘空间<br>限制某一用户组/用户所能使用的最大磁盘配额<br>quota的规范设置选项<br>容量限制或者文件数量限制<br>soft(警告)/hard<br>edquota 编辑账号/用户组的限值和宽限时间<br>quota 单一用户的报表<br>repquota 针对文件系统的限额做报表<br>warnquote 对超过限额发出警告信</p>
<p>第16章 例行性工作 crontab<br>16.1.1 Linux工作调度的种类 at，cron<br>at 是可以处理仅执行一次就结束调度的命令 要执行at，要有atd这个服务<br>crontab 设置的工作会一直循环进行下去。编辑/etc/crontab 支持， 让crontab生效的服务是crond这个服务</p>
<p>16.1.2 Linux例行性任务<br>进行日志文件的论题<br>日志文件分析 logwatch的任务<br>新建locate的数据库<br>whatis 数据库的建立<br>RPM软件日志文件的新建<br>删除临时文件<br>与网络服务有关的分析行为</p>
<p>16.2.1 atd的启动与at运行的方式<br>/etc/init.d/atd restart<br>at 的运行方式<br>将工作以文本文件的方式写入/var/spool/at/目录，该工作便能等待atd服务取用和执行<br>可以利用/etc/at.allow /etc/at.deny 给at限制<br>先找at.allow  写在这个文件的用户才能at<br>at.allow不存在就寻找 at.deny 如果在at.deny就不能at，没有在deny的则可以at<br>两个文件都不存在，就不能使用at这个命令</p>
<p>16.2.2 实际运行单一工作调度<br>at  [-mldv] TIME<br>at -c 工作号码  ctrl+d 代表结束<br>由于at工作调度的使用，系统会将该项at工作独立出bash环境，交给系统的atd程序接管<br>at工作的管理<br>atq 与 atrm<br>batch 系统有空时才进行后台任务， 在工作负载小于0.8 才进行执行工作任务<br>batch 也是atq 与atrm管理。</p>
<p>16.3.1 crontab 使用限制<br>/etc/cron.allow 将可以只用crontab的账号写入，不在这个文件不能用crontab<br>/etc/cron.deny 不可以使用的账号写入，不在文件中的都可以使用，有限判断allow<br>用户使用crontab新建工作调度后，这项工作就被记录到/var/spool/cron里面，以账号判别<br>cron执行的每一项工作都会记录到/var/log/cron<br>crontab 六个字段的意义<br>数字范围  分钟 小时 日期 月份 周 命令 </p>
<ul>
<li>表示任何时刻 , 表示分隔时段 - 表示范围  /n  表示每隔n单位</li>
</ul>
<p>16.3.2 系统的配置文件 /etc/crontab<br>cron服务的最低检测限制是分钟，cron会每分钟读取一次/etc/crontab 与 /etc/spool/cron 里面的数据</p>
<p>16.3.3 一些注意事项<br>资源分配不匀  注意隔开执行任务<br>取消不要的输出选项<br>安全校验<br>周与日月不可同时并存</p>
<p>16.4 可唤醒停机期间的工作任务<br>anacron 开机会去检测停机期间应该执行但没执行的crontab，将任务执行一遍，然后anacron就停止<br>anacron 也是通过crontab运行，anacron 运行的时间通常有两个，一个是系统开机期间运行，一个是写入crontab 调度</p>
<p>17 程序管理与SELinux初探<br>17.1  在Linux系统中，触发任何一个事件，系统都会将它定义成为一个进程，并且给与这个进程一个ID，成为PID，同时依据触发这个进程的用户与相关属性关系，给与这个PID一组有效的权限设置。</p>
<p>17.1.1 进程与程序<br>用户登录并执行bash时，系统已经给我们一个PID<br>这个进程衍生出来的其他进程一般状态下，也会沿用这个进程的相关权限<br>程序 通常为二进制程序防止在存储媒介中（如硬盘、光盘、软盘、磁带等），以物理文件的形式存在<br>进程 程序被处罚后，执行者的权限与属性、程序的程序代码与所需数据等都会被加载到内存中，操作系统并给予这个内存内的单元一个标示符PID，可以说，进程就是运行中的程序<br>父进程与子进程<br>在bash中执行的shell，会被触发产生新的PID，就是子进程<br>fork and exec 过程调用的流程<br>进程通常都会通过父进程以复制（fork）的方式产生一个一模一样的子进程，然后被复制出来的子进程再以exec的方式执行实际要执行的进程，最终就成为一个子进程的存在。<br>系统与网络服务：常驻在内存中的进程<br>常驻进程被称为服务</p>
<p>17.1.2 Linux的多用户 多任务环境<br>多重登录环境的七个基本终端窗口，Linux当中提供了6个命令行界面登录窗口和一个图形界面窗口，可以用ALT + F1-F7切换<br>bash环境下的工作管理<br>cp file1 file2 &amp;  &amp;的功能表示执行防止于后台中执行，执行完毕后系统将在终端显示完成的信息</p>
<p>17.2 工作管理<br>17.2.1 JOB control必须注意<br>1 这些工作所触发的进程必须来自shell的子进程<br>2 前台：可以控制欲执行命令的环境成为前台的工作<br>3 后台：可以自行运行的工作，无法使用Ctrl+C终止，可以使用bg/fg调用该工作<br>4 后台中执行的程序不能等待terminal/shell的输入</p>
<p>17.2.2 job control的管理<br>后台工作状态分为暂停与运行中<br>实际进行job控制的命令<br>1直接将命令丢到后台中执行的&amp;<br>2 将目前的工作丢到后台中“暂停” Ctrl-z<br>3 查看目前的后台工作状态 jobs + 代表最近被放到后台的工作 -代表最后第二个放置的，超过最后第三个就没有符号<br>4 将后台工作拿到前台来处理  fg jobnumber<br>5 让工作在后台下的状态变成运行中 bg<br>6 管理后台当中的工作 kill<br>kill -signal jobnumber  signal 代表 -1 重新读取一次参数配置文件 -2 代表与键盘输入Ctrl+c一样的操作 -9 立刻强制删除一个工作 -15 里正常的程序方式终止一项工作（默认值）</p>
<p>17.2.3 脱机管理<br>远程连接到Linux，脱机后，bash后台工作会停止，可以使用at， 因为at是放在系统后台的<br>也可以使用nohup  可以在脱机或者注销系统后，工作继续进行</p>
<p>17.3 进程管理<br>17.3.1 进程的查看 静态的ps 或者动态的top<br>ps 将某个时间点的进程运行情况选取下来<br>ps -l现实的数据内容<br>F ： 代表进程标志，说明进程权限  4表示进程权限为root  1 表示此子进程仅可进行复制而无法实际执行。<br>S ： 代表这个进程的状态（STAT)， 主要状态 R Running S Sleep D 不可被唤醒的睡眠状态 通常这个进程在等待I/O的情况 T 停止状态，可能在工作控制或出错状态  Z 僵尸状态，进程已经终止但无法删除至内存外<br>UID/PID/PPID<br>C ：CPU使用率  单位百分比<br>PRI/NI ： 代表此进程被CPU执行的优先级，数值越小代表该进程越快被CPU执行。<br>ADDR/SZ/WCHAN ： 与内存有关 ADDR 指出进程在内存哪个部分，如果running，显示- SZ 代表次进程使用多少内存 WCHAN 表示进程是否运行中  -表示运行中<br>TTY ： 登陆者的终端机位置，若为远程登录则使用动态终端接口（pts/n)<br>TIME ： 使用掉的CPU时间，此进程实际花费CPU的运行时间，不是系统时间<br>CMD ： 触发进程的命令<br>如果发现某个进程后的CMD后接上 <defunct> 代表该进程是僵尸进程<br>top 动态查看进程变化<br>自己的bash PID可以使用echo $$ 取得<br>pstree 所有的进程都衣服在init这个进程下面，</defunct></p>
<p>17.3.2 进程的管理<br>可以给进程一个signal去告知该进程你想让做什么<br>kill可以帮我们把signal传送给某个工作或者某个PID。<br>killall 利用执行命令的名称发送信息</p>
<p>17.3.3 关于进程的执行顺序<br>Linux给予进程一个优先执行序，priority（PRI） PRI值越低代表越优先执行，不过PRI是内核动态调整的，用户无法直接调整。<br>如果想要调整进程优先执行序，通过Nice（NI） 一般 PRI(new) = PRI(old) + nice<br>nice 取值范围 -20 - 19<br>如何给予nice<br>1 用nice命令 nice 新之星的命令即给予新的nice值<br>2 调整某个PID的nice值，用renice命令</p>
<p>17.3.4 系统资源的查看<br>free 查看内存使用情况<br>uname 查看系统与内核相关信息<br>uptime 查看系统启动时间与工作负载<br>netstat 跟踪网络<br>dmesg 分析内核产生的信息<br>vmstat 检测系统资源变化</p>
<p>17.4 特殊文件与程序<br>14.4.1 具有SUID/SGID权限的命令执行状态<br>SUID 权限仅对二进制程序有效<br>执行者对于该程序需要具有x的可执行权限<br>本权限仅在执行该程序的过程中有效<br>执行者将具有该程序所有者的权限</p>
<p>17.4.2 /proc/* 代表的意义<br>主机上面的各个进程的PID都是以目录的类型存在于/proc中<br>cmdline 这个进程被启动的命令串<br>environ 这个<br>进程的环境变量内容</p>
<p>17.4.3 查询已经打开文件或已执行程序打开的文件<br>fuser 通过文件找出正在使用该文件的程序<br>lsof 列出正被进程所打开的文件名<br>pidof 找出某个正在执行的进程的PID</p>
<p>17.5SELinux 初探<br>17.5.2 SELinux  运行模式<br>主体  进程<br>目标 文件系统<br>策略 targeted 针对网络服务限制较多，针对本机限制较少 strict 完整SElinux 限制 较为严格<br>安全上下文 主体与目标的安全上下文必须一致才能顺利访问<br>安全上下文是放置到文件inode内<br>ls -Z 查看文件安全上下文权限 身份识:角色:类型</p>
<p>18 认知服务系统<br>18.1 实现service的程序叫做 daemon<br>18.1.1 deamon的主要分类<br>stand_alone 可以单独启动服务的deamon 如 httpd<br>super daemon  一个特殊的daemon统一管理  如Telnet<br>super daemon 处理模式有两种，分别是<br>multi-threaded 多线程<br>single-threaded 单线程<br>deamon命名规则 通常服务后面会加上一个d</p>
<p>18.1.2 服务与端口的对应<br>服务和端口号对应的设置 /etc/services</p>
<p>18.1.3 daemon的启动脚本与启动方式<br>一般distribution会给一个简单的shell script，可以进行环境监测、配置文件分析、PID文件放置、相关重要交换文件的锁住操作，直接启动。<br>配置文件放在:<br>/etc/init.d/ 启动脚本放置处<br>/etc/sysconfig/<em> 各服务的初始化环境配置文件<br>/etc/xinetd.conf /etc/xinetd.d/</em>   super daemon的配置文件<br>/etc/<em> 各服务各自的配置文件<br>/var/lib/</em> 各服务产生的数据库<br>/var/run/* 各服务的程序的PID记录处</p>
<p>18.2 解析super daemon的配置文件<br>super daemon 是xinetd这个进程实现的。 默认配置文件 /etc/xinetd.conf</p>
<p>18.3   服务的防火墙管理xinetd TCP Wrappers<br>18.3.1 /etc/hosts.allow /etc/hosts.deny<br>任何以xinetd 管理的服务都可以以hosts.deny|allow 做防火墙，不支持TCP Wrappers函数功能，就不能用hosts做防火墙<br>ldd 可以查询某个命令的动态函数库支持状态</p>
<p>18.3.2 TCP wrappers 特殊功能</p>
<p>18.4 系统开启的服务<br>18.4.2 设置开机后立即启动服务的方法<br>Linux 主机怎么开机的<br>1 打开计算机电源，开始读取BIOS并进行主机的自我测试<br>2 通过BIOS取得第一个可开开机设备，读取主要开机区(MBR)取得启动装载程序<br>3 通过启动装载程序的设置取得kernel并加载内存且检测系统硬件<br>4 内核主动调用init进程<br>5 init进程开始执行系统初始化(/etc/rc.d/rc.sysinit)<br>6依据init的设置进行daemonstart(/etc/rc.d/rc[0-6].d/*<br>7加载本机设置/etc/rc.d/rc.local<br>chkconfig 管理系统服务默认开机启动与否 ， 还可以设置自己的系统服务<br>ntsysv 类图形界面管理模式</p>
<p>18.4.3 CentOs 5.x 默认启动的服务简易说明</p>
<p>19 认识与分析日志文件<br>19.1 日志文件所需相关服务于进程<br>syslogd 主要登录系统与网络等服务的信息<br>klogd 主要登录内核产生的各项信息<br>logrotate 主要进行日志文件的轮替功能</p>
<p>19.2 syslogd 记录日志文件的服务<br>19.2.1 日志文件内容的一般格式<br>每条信息会记录下面的重要数据：<br>1 事件发生的日期与时间<br>2 发生此事件的主机名<br>3 启动此事件的服务名称<br>4 该信息的实际数据内容</p>
<p>19.2.2 syslog的配置文件 /etc/syslog.conf<br>这个文件设定了什么服务的什么等级信息以及需要被记录在哪里<br>数据分为三部分<br>服务名称<br>信息等级 1 info 2 notice 3 warning 4 err 5 crit 6 alert 7 emerg   还有debug与none  . 代表比后面还要高级的等级都被记录下来 .= 代表所需要的等级就是后面接的等级 .! 除了后面接的等级<br>信息记录的文件名或设备或主机</p>
<p>19.2.3 日志文件的安全性设置<br>syslog被编辑过就无法继续记录了<br>chattr +a </p>
<p>19.2.4 日志文件服务器的设置</p>
<p>19.3 日志文件的轮替 logrotate<br>logrotate 挂在cron下面的<br>logrotate 的参数放置在<br>1 /etc/logrotate.conf<br>2 /etc/logrotate.d/</p>
<p>19.4 分析日志文件<br>19.4.1 CentOS提供的logwatch</p>
<p>20 启动流程、模块管理与Loader<br>20.1 Linux的启动流程分析<br>20.1.1 启动流程一览<br>1 加载BIOS 的硬件信息与进行自我测试，并依据设置取得第一个可启动的设备<br>2 读取并执行第一个启动设备内的MBR的boot Loader （即是grub spfdisk等程序）<br>3 依据boot Loader的设置加载kernal，kernal会开始检测硬件和加载驱动程序<br>4 在硬件驱动成功后，kernel会主动调用init进程，而init会取得run-level信息<br>5 init 执行/etc/rc.d/rc.sysinit 文件来准备软件执行的操作环境 （如网络 时区等）<br>6 init 执行run-level的各个服务的启动（script方式）<br>7 init 执行 /etc/rc.d/rc.local文件<br>8init执行终端机模拟成宿mingetty启动login进程，最后等待用户登录</p>
<p>20.1.3 第一个进程init与配置文件/etc/inittab 与runlevel<br>run level 执行等级<br>0 - halt 系统直接关机<br>1 - single user mode 单用户维护模式用在系统出问题时的维护<br>2 - Multi-user without NFS<br>3 － full multi-user mode 完整含有网络功能的纯文本模式<br>4 - unused 系统保留模式<br>5 - X11 与runlevel3 类似但是使用x-window<br>6 - reboot 重新启动<br>init 的处理流程<br>1 取得runlevel 即默认执行等级的相关等级<br>2 使用/etc/rc.d/rc.sysinit 进行系统初始化<br>3 优于runlevel 是5 ，因此只进行 5:5:wait:/etc/rc.d/rc5<br>4 设置好 crtl+alt+del 组合键<br>5 设置不断电系统的pf,pr两种机制<br>6 启动mingetty的6个终端机<br>7 最终以/etc/X11/perfdm -nodaemon 启动图形界面</p>
<p>20.1.4 init 处理系统初始化流程 /etc/rd/d/rc.sysinit<br>1 取得网络环境与主机类型<br>2 测试与挂载内存设备 /proc 及 USB 设备/sys<br>3 决定是否启动SELinux<br>4。。。。。。。。<br>自定义的模块写入/etc/sysconfig/modules/*.modules 中</p>
<p>20.1.5 启动系统服务与相关启动配置文件 /etc/rc.d/rc &amp; /etc/sysconfig</p>
<p>20.1.6 用户自定义开机启动程序 /etc/rc.d/local</p>
<p>20.1.7 根据/etc/inittab 的设置加载终端机或X Window 界面 </p>
<p>20.1.8 启动过程会用到的主要配置文件<br>关于模块 /etc/modprobe.conf<br>/etc/sysconfig/*</p>
<p>20.1.9 Run level的切换<br>runlevel查看当前level<br>init* 指定切换level</p>
<p>20.2 内核与内核模块<br>20.2.1 内核模块与依赖性<br>depmod 记录了内核模块的依赖性</p>
<p>20.3 Boot Loader：Grub<br>20.3.1 boot Loader的两个stage<br>因为MBR很小，所以Loader分为两个阶段<br>stage1 执行 boot loader 主程序<br>stage2 主程序加载配置文件</p>
<p>20.3.8 为某个菜单加上密码<br>grub-md5-crypt 可以生成一个md5密码</p>
<p>21 系统设置工具（网络与打印机）与硬件检测<br>21.1.2 网络配置选项(手动设置IP 与自动获取)<br>Linux称以太网卡网络接口为ethN<br>重新启动网络 /etc/init.d/network restart</p>
<p>21.2  打印<br>打印步骤<br>1 打印操作<br> 2 打印队列<br>3 打印服务</p>
<p>22 软件安装：源码与Tarball<br>22.1.1 什么是开放源码、编译程序与可执行文件<br>Linux系统上真正识别的可执行文件其实是二进制文件<br>file 查看是否可执行文件类(ELF)<br>程序代码文件就是一般的纯文本文件，将文件编译成操作系统看得懂的二进制程序。<br>开放源码：就是程序代码，写给人类看的程序语言，机器不认识，所以无法执行<br>编译程序：将程序代码转译成机器看得懂的语言，类似翻译者的角色<br>可执行文件：经过编译程序编程二进制程序后机器可以看得懂的所以可以执行的文件</p>
<p>22.1.2 什么是函数库<br>函数库，类似子程序的角色，可以被调用来执行的一段功能函数</p>
<p>22.1.3 什么是make与configure<br>执行make时，就会在当前目录下搜索makefile 这个文本文件，Makefile里面记录了源码如何编译的详细信息。<br>软件开发商会写一个检测程序检测用户的操作环境，以及操作环境是否有软件开发商所需要的其他功能，该检测程序检测完毕后会主动创建Makefile的规则文件。通常这个检测程序的文件名为configure或config<br>检测程序会检测<br>1 是否有适合的编译程序可以编译本软件的程序代码<br>2 是否已经存在本软件所需要的函数库或其他需要的相关软件<br>3 操作系统平台是否适合本软件，包括Linux的内核版本<br>4 内核的头定义文件是否存在</p>
<p>22.1.4 什么是tarball的软件<br>所谓Tarball，就是将软件的所有源码文件先以tar打包，然后再以压缩技术压缩，最常见的就是以gzip压缩。<br>解压缩后通常会有<br>1 源代码文件<br>2 检测程序文件（可能是configure 或 config等文件名）<br>3 本软件的简易说明与安装说明</p>
<p>22.1.5 如何安装与升级软件<br>更新方法<br>1 直接以源码通过编译来安装与升级<br>2 直接以编译好的二进制程序安装与升级<br>安装流程<br>以gcc进行源码编译（会生成目标文件）<br>以gcc进行函数库、主程序、子程序的链接，以形成主要的二进制文件<br>将上述的二进制文件以及相关配置文件安装至自己主机</p>
<p>22.2 使用传统程序语言进行编译的简单案例<br>22.2.1 单一程序：打印hello world<br>1 编辑源码 hello.c<br>2 开始编译与测试执行 gcc hello.c</p>
<p>22.2.2 主程序、子程序链接：子程序的编译<br>源码文件不是一个文件，所以无法直接编译，要先生成目标文件，再以链接制作成为二进制可执行文件</p>
<p>22.2.3 调用外部函数库：加入链接的函数库<br>编译时加入额外函数库链接的方式</p>
<p>22.2.4 gcc的建议用法（编译、参数与链接）<br>gcc -c O lm </p>
<p>22.3 用make进行宏编译<br>22.3.1 为什么要用make<br>简化编译时所需要的命令<br>若在编译完成之后，修改了某个源码文件，则make仅会针对被修改了的文件进行编译，其他的目录文件不会被更改<br>最后可以依照相关性来更新执行文件</p>
<p>22.3.2 makefile的基础语法与变量<br>基础的Makefile语法<br>目标(target)：目标文件1 目标文件2</p>
<p><tab>  gcc -o 欲新建的可执行文件 目标文件1 目标文件2<br>规则<br>在Makefile当中的#代表批注</tab></p>
<p><tab> 需要再命令行（例如gcc 这个编译命令）的第一个字符<br>目标(target) 与相关文件（就是目标文件）之间需要以 : 隔开<br>环境变量取用的规则：<br>1 make命令后面加上的环境变量为第一优先<br>2 Makefile 里面指定的环境变量为第二优先<br>3 shell 原本具有的环境变量为第三优先</tab></p>
<p>22.4 Tarball的管理与建议<br>22.4.2 Tarball的安装步骤<br>1 取得源文件，放在/usr/local/src 下 tar 解压<br>2 取得步骤流程 ：查阅INSTALL 与 README<br>3 相关属性软件安装：根据INSTALL/README 查看并安装好一些相关软件（非必要）<br>4 简历Makefile，以自检测程序configure或config建立Makefile<br>5 编译 以make使用Makefile进行编译<br>6 安装 make install  把编译完成的文件放到正确的目录</p>
<p>22.4.5 利用patch更新源码</p>
<p>22.5 函数库管理<br>22.5.1 动态与静态函数库<br>静态函数库特色<br>1 扩展名为.a<br>2 编译行为 直接整合到执行程序<br>3 独立执行的状态 编译成功可以独立执行，不需要向外部要求读取函数库内容<br>4 升级难易度  难 需要重新编译<br>动态函数库特色<br>1 扩展名为 .so<br>2 编译行为 程序里只有一个指向位置<br>3 独立执行的状态 不能被独立执行<br>4 升级难易度 易</p>
<p>22.5.2 ldconfig 与 /etc/ld.so.conf<br>把动态函数库加载到告诉缓存<br>1 首先 在/etc/ld.so.conf 写入要读入高速缓存中的动态函数库所在目录<br>2 利用ldconfig 将/etc/ld.so.conf 数据读入缓存<br>3 同时将数据记录一份到/etc/ld.so.cache </p>
<p>22.5.3 程序的动态函数库解析 ldd </p>
<p>22.6 检验软件正确性<br>md5sum<br>sha1sum </p>
<p>23软件安装  RPM 、SRPM 与 YUM<br>23.1.2 什么是RPM与SRPM<br>RPM RedHat Package Manager 是以一种数据库记录的方式将需要的软件安装到Linux系统的管理机制<br>1 软件安装的环境必须与打包时的环境需求一致或相当<br>2 需要满足软件的依赖属性需求<br>3 反安装时需要特别小心，最底层软件不可先删除，否则可能造成整个系统问题<br>SRPM<br>1 先将软件以RPM管理方式编译，此事SRPM会被编译成RPM<br>2 然后将RPM文件安装到Linux</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/10/23/linux_learn/" data-id="cjpnx4fcw001fuy38psqx1gdy" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux/">linux</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2018/08/23/add_service/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          (no title)
        
      </div>
    </a>
  
  
    <a href="/2001/08/23/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hexo 博客搭建指南</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/crontab/">crontab</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git-linux/">git linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json/">json</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/linux/">linux</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mac-os/">mac os</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql/">mysql</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/mysql-node-js/">mysql node.js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/php/">php</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/计算机系统/">计算机系统</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/crontab/" style="font-size: 13.33px;">crontab</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/git-linux/" style="font-size: 10px;">git linux</a> <a href="/tags/golang/" style="font-size: 16.67px;">golang</a> <a href="/tags/json/" style="font-size: 10px;">json</a> <a href="/tags/linux/" style="font-size: 20px;">linux</a> <a href="/tags/mac-os/" style="font-size: 10px;">mac os</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/mysql/" style="font-size: 10px;">mysql</a> <a href="/tags/mysql-node-js/" style="font-size: 10px;">mysql node.js</a> <a href="/tags/php/" style="font-size: 10px;">php</a> <a href="/tags/计算机系统/" style="font-size: 10px;">计算机系统</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/12/">December 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/11/">November 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/10/">October 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">October 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2001/08/">August 2001</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/12/13/indeedsystem/chapter1/">第一章 计算机系统漫游</a>
          </li>
        
          <li>
            <a href="/2018/12/07/linux_quick/">定时任务不能确认完成时间的解决方法</a>
          </li>
        
          <li>
            <a href="/2018/12/06/git_no_pass/">Git服务器配置指定客户端免密</a>
          </li>
        
          <li>
            <a href="/2018/12/06/git_new/">Git服务器新建项目</a>
          </li>
        
          <li>
            <a href="/2018/12/06/reset_mysql_root/">Mac OS MySQL重置root密码</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 Cli<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>